var e,t,s,a,i,r,n,o,c,h,l,d,w,u=Object.defineProperty,p=(e,t,s)=>(((e,t,s)=>{t in e?u(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s})(e,"symbol"!=typeof t?t+"":t,s),s),y=(e,t,s)=>{if(!t.has(e))throw TypeError("Cannot "+s)},m=(e,t,s)=>(y(e,t,"read from private field"),s?s.call(e):t.get(e)),v=(e,t,s)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,s)},g=(e,t,s,a)=>(y(e,t,"write to private field"),a?a.call(e,s):t.set(e,s),s),f=(e,t,s)=>(y(e,t,"access private method"),s);import{W as S,r as k,h as E,a as b,H as M,J as A}from"./ethers-vendor.js";const x=(e,t,s,a)=>function(...i){return new(0,t.promiseModule)(((r,n)=>{t.multiArgs?i.push(((...e)=>{t.errorFirst?e[0]?n(e):(e.shift(),r(e)):r(e)})):t.errorFirst?i.push(((e,t)=>{e?n(e):r(t)})):i.push(r);const o=this===s?a:this;Reflect.apply(e,o,i)}))},N=new WeakMap;function K(e,t){t={exclude:[/.+(?:Sync|Stream)$/],errorFirst:!0,promiseModule:Promise,...t};const s=typeof e;if(null===e||"object"!==s&&"function"!==s)throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${null===e?"null":s}\``);const a=new WeakMap,i=new Proxy(e,{apply(e,s,r){const n=a.get(e);if(n)return Reflect.apply(n,s,r);const o=t.excludeMain?e:x(e,t,i,e);return a.set(e,o),Reflect.apply(o,s,r)},get(e,s){const r=e[s];if(!((e,s)=>{let a=N.get(e);if(a||(a={},N.set(e,a)),s in a)return a[s];const i=e=>"string"==typeof e||"symbol"==typeof s?s===e:e.test(s),r=Reflect.getOwnPropertyDescriptor(e,s),n=void 0===r||r.writable||r.configurable,o=(t.include?t.include.some((e=>i(e))):!t.exclude.some((e=>i(e))))&&n;return a[s]=o,o})(e,s)||r===Function.prototype[s])return r;const n=a.get(r);if(n)return n;if("function"==typeof r){const s=x(r,t,i,e);return a.set(r,s),s}return r}});return i}var P=(w=class{constructor({area:w="sync",allCopied:u=!1,copiedKeyList:y=[],serde:S={}}={}){v(this,c),v(this,l),v(this,e,void 0),v(this,t,void 0),v(this,s,void 0),v(this,a,void 0),v(this,i,new Map),v(this,r,void 0),p(this,"isCopied",(e=>this.hasWebApi&&(this.allCopied||this.copiedKeySet.has(e)))),v(this,n,!1),p(this,"getExtStorageApi",(()=>{var e,t;return(null==(e=globalThis.browser)?void 0:e.storage)||(null==(t=globalThis.chrome)?void 0:t.storage)})),p(this,"isWatchSupported",(()=>this.hasExtensionApi)),p(this,"keyNamespace",""),p(this,"isValidKey",(e=>e.startsWith(this.keyNamespace))),p(this,"getNamespacedKey",(e=>`${this.keyNamespace}${e}`)),p(this,"getUnnamespacedKey",(e=>e.slice(this.keyNamespace.length))),p(this,"serde",{serializer:JSON.stringify,deserializer:JSON.parse}),p(this,"rawGetAll",(()=>{var e;return null==(e=m(this,t))?void 0:e.get()})),p(this,"getAll",(async()=>{let e=await this.rawGetAll();return Object.entries(e).filter((([e])=>this.isValidKey(e))).reduce(((e,[t,s])=>(e[this.getUnnamespacedKey(t)]=s,e)),{})})),p(this,"copy",(async e=>{var a,i;let r=void 0===e;if(!r&&!this.copiedKeySet.has(e)||!this.allCopied||!this.hasExtensionApi)return!1;let n=this.allCopied?await this.rawGetAll():await m(this,t).get((r?[...this.copiedKeySet]:[e]).map(this.getNamespacedKey));if(!n)return!1;let o=!1;for(let t in n){let e=n[t],r=null==(a=m(this,s))?void 0:a.getItem(t);null==(i=m(this,s))||i.setItem(t,e),o||(o=e!==r)}return o})),p(this,"rawGet",(async e=>(await this.rawGetMany([e]))[e])),p(this,"rawGetMany",(async e=>this.hasExtensionApi?await m(this,t).get(e):e.filter(this.isCopied).reduce(((e,t)=>{var a;return e[t]=null==(a=m(this,s))?void 0:a.getItem(t),e}),{}))),p(this,"rawSet",(async(e,t)=>await this.rawSetMany({[e]:t}))),p(this,"rawSetMany",(async e=>(m(this,s)&&Object.entries(e).filter((([e])=>this.isCopied(e))).forEach((([e,t])=>m(this,s).setItem(e,t))),this.hasExtensionApi&&await m(this,t).set(e),null))),p(this,"clear",(async(e=!1)=>{var a;e&&(null==(a=m(this,s))||a.clear()),await m(this,t).clear()})),p(this,"rawRemove",(async e=>{await this.rawRemoveMany([e])})),p(this,"rawRemoveMany",(async e=>{m(this,s)&&e.filter(this.isCopied).forEach((e=>m(this,s).removeItem(e))),this.hasExtensionApi&&await m(this,t).remove(e)})),p(this,"removeAll",(async()=>{let e=await this.getAll(),t=Object.keys(e);await this.removeMany(t)})),p(this,"watch",(e=>{let t=this.isWatchSupported();return t&&m(this,o).call(this,e),t})),v(this,o,(t=>{var s;for(let a in t){let r=this.getNamespacedKey(a),n=(null==(s=m(this,i).get(r))?void 0:s.callbackSet)||new Set;if(n.add(t[a]),n.size>1)continue;let o=(e,t)=>{if(t!==this.area||!e[r])return;let s=m(this,i).get(r);if(!s)throw new Error(`Storage comms does not exist for nsKey: ${r}`);Promise.all([this.parseValue(e[r].newValue),this.parseValue(e[r].oldValue)]).then((([e,a])=>{for(let i of s.callbackSet)i({newValue:e,oldValue:a},t)}))};m(this,e).onChanged.addListener(o),m(this,i).set(r,{callbackSet:n,listener:o})}})),p(this,"unwatch",(e=>{let t=this.isWatchSupported();return t&&f(this,c,h).call(this,e),t})),p(this,"unwatchAll",(()=>f(this,l,d).call(this))),this.setCopiedKeySet(y),g(this,a,w),g(this,n,u),this.serde={...this.serde,...S};try{this.hasWebApi&&(u||y.length>0)&&g(this,s,window.localStorage)}catch{}try{this.hasExtensionApi&&(g(this,e,this.getExtStorageApi()),(()=>{var e,t,s;try{let a=(null==(e=globalThis.navigator)?void 0:e.userAgent).match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i)||[];if("Chrome"===a[1])return parseInt(a[2])<100||2===(null==(s=null==(t=globalThis.chrome.runtime)?void 0:t.getManifest())?void 0:s.manifest_version)}catch{return!1}return!1})()?g(this,t,K(m(this,e)[this.area],{exclude:["getBytesInUse"],errorFirst:!1})):g(this,t,m(this,e)[this.area]))}catch{}}get primaryClient(){return m(this,t)}get secondaryClient(){return m(this,s)}get area(){return m(this,a)}get hasWebApi(){try{return typeof window<"u"&&!!window.localStorage}catch(e){return!1}}get copiedKeySet(){return m(this,r)}get allCopied(){return m(this,n)}get hasExtensionApi(){try{return!!this.getExtStorageApi()}catch(e){return!1}}setCopiedKeySet(e){g(this,r,new Set(e))}async getItem(e){return this.get(e)}async getItems(e){return await this.getMany(e)}async setItem(e,t){await this.set(e,t)}async setItems(e){await await this.setMany(e)}async removeItem(e){return this.remove(e)}async removeItems(e){return await this.removeMany(e)}},e=new WeakMap,t=new WeakMap,s=new WeakMap,a=new WeakMap,i=new WeakMap,r=new WeakMap,n=new WeakMap,o=new WeakMap,c=new WeakSet,h=function(t){for(let s in t){let a=this.getNamespacedKey(s),r=t[s],n=m(this,i).get(a);n&&(n.callbackSet.delete(r),0===n.callbackSet.size&&(m(this,i).delete(a),m(this,e).onChanged.removeListener(n.listener)))}},l=new WeakSet,d=function(){m(this,i).forEach((({listener:t})=>m(this,e).onChanged.removeListener(t))),m(this,i).clear()},w);const C=new class extends P{constructor(){super(...arguments),p(this,"get",(async e=>{let t=this.getNamespacedKey(e),s=await this.rawGet(t);return this.parseValue(s)})),p(this,"getMany",(async e=>{let t=e.map(this.getNamespacedKey),s=await this.rawGetMany(t),a=await Promise.all(Object.values(s).map(this.parseValue));return Object.keys(s).reduce(((e,t,s)=>(e[this.getUnnamespacedKey(t)]=a[s],e)),{})})),p(this,"set",(async(e,t)=>{let s=this.getNamespacedKey(e),a=this.serde.serializer(t);return this.rawSet(s,a)})),p(this,"setMany",(async e=>{let t=Object.entries(e).reduce(((e,[t,s])=>(e[this.getNamespacedKey(t)]=this.serde.serializer(s),e)),{});return await this.rawSetMany(t)})),p(this,"remove",(async e=>{let t=this.getNamespacedKey(e);return this.rawRemove(t)})),p(this,"removeMany",(async e=>{let t=e.map(this.getNamespacedKey);return await this.rawRemoveMany(t)})),p(this,"setNamespace",(e=>{this.keyNamespace=e})),p(this,"parseValue",(async e=>{try{if(void 0!==e)return this.serde.deserializer(e)}catch(t){}}))}},W=1e4,U=[{chainId:"0x1",name:"Ethereum Mainnet",rpcUrl:"https://mainnet.infura.io/v3/6131105f1e4c4841a297c5392effa977",currencySymbol:"ETH",blockExplorerUrl:"https://etherscan.io"},{chainId:"0xaa36a7",name:"Sepolia Testnet",rpcUrl:"https://sepolia.infura.io/v3/6131105f1e4c4841a297c5392effa977",currencySymbol:"ETH",blockExplorerUrl:"https://sepolia.etherscan.io"}];const I=new class{constructor(){p(this,"vault",null),p(this,"state",{isUnlocked:!1,accounts:[],networks:U,selectedNetwork:U[0],connectedSites:{}}),p(this,"initPromise"),p(this,"pendingNetworkUpdate",null),p(this,"password",null),this.initPromise=this.loadState()}async loadState(){try{const e=await Promise.race([C.get("walletState"),new Promise(((e,t)=>setTimeout((()=>t(new Error("Loading state timed out"))),W)))]);e&&(this.state=JSON.parse(e))}catch(e){}}async saveState(){try{await Promise.race([C.set("walletState",JSON.stringify(this.state)),new Promise(((e,t)=>setTimeout((()=>t(new Error("Saving state timed out"))),W)))])}catch(e){throw new Error("Failed to save wallet state")}}async getState(){return await this.initPromise,this.state}async saveUsername(e){try{await Promise.race([C.set("username",e),new Promise(((e,t)=>setTimeout((()=>t(new Error("Saving username timed out"))),W)))])}catch(t){throw new Error("Failed to save username")}}async setConnected(e){try{this.state.isUnlocked=e,await this.saveState()}catch(t){throw new Error("Failed to set connection state")}}async hasWallet(){return await this.initPromise,null!==this.vault}async resetWallet(){await this.initPromise,this.vault=null,this.state.isUnlocked=!1,this.state.accounts=[],this.state.selectedAccount=void 0,await this.saveState(),await C.remove("vault")}async createWallet(e,t=!1){var s;if(await this.initPromise,this.vault&&!t)throw new Error("Wallet already exists. Use force=true to overwrite existing wallet.");try{const t=await Promise.race([S.createRandom(),new Promise(((e,t)=>setTimeout((()=>t(new Error("Wallet creation timed out"))),W)))]);if(!(null==(s=t.mnemonic)?void 0:s.phrase))throw new Error("Failed to generate wallet mnemonic");const a=k(32),i=k(16),r=await this.encryptSeed(t.mnemonic.phrase,e,a,i);this.vault={encryptedSeed:r,salt:E(a),iv:E(i),version:1},this.password=e,await C.set("vault",this.vault),this.state.isUnlocked=!0,await this.saveState(),await new Promise((e=>setTimeout(e,100))),await this.addAccount("Account 1")}catch(a){throw this.vault=null,this.password=null,this.state.isUnlocked=!1,await this.saveState(),a instanceof Error?new Error(`Failed to create wallet: ${a.message}`):new Error("Failed to create wallet: Unknown error")}}async unlockWallet(e){const t=await C.get("vault");if(!t)throw new Error("No wallet found");try{await this.decryptSeed(t.encryptedSeed,e,b(t.salt),b(t.iv));return this.vault=t,this.state.isUnlocked=!0,await this.saveState(),!0}catch(s){return!1}}async addAccount(e){if(!this.vault||!this.state.isUnlocked)throw new Error("Wallet is locked");const t=this.state.accounts.length,s=`m/44'/60'/0'/0/${t}`,a=await this.getSeed(),i=M.fromMnemonic(a).derivePath(s),r={address:new S(i.privateKey).address,name:e||`Account ${t+1}`,index:t,balances:{}};return this.state.accounts.push(r),this.state.selectedAccount||(this.state.selectedAccount=r),await this.saveState(),r}async getAccounts(){return this.state.accounts}async setNetwork(e){const t=this.state.networks.find((t=>t.chainId===e));if(!t)throw new Error("Network not found");this.state.selectedNetwork=t,await this.saveState()}async addNetwork(e){if(this.state.networks.some((t=>t.chainId===e.chainId)))throw new Error("Network already exists");this.state.networks.push(e),await this.saveState()}async signTransaction(e){if(!this.vault||!this.state.isUnlocked)throw new Error("Wallet is locked");const t=await this.getSeed(),s=this.state.accounts.find((t=>t.address.toLowerCase()===e.from.toLowerCase()));if(!s)throw new Error("Account not found");const a=`m/44'/60'/0'/0/${s.index}`,i=M.fromMnemonic(t).derivePath(a),r=new S(i.privateKey),n=new A(this.state.selectedNetwork.rpcUrl),o=r.connect(n);return await o.signTransaction({to:e.to,value:e.value,data:e.data,nonce:e.nonce,gasLimit:e.gasLimit,gasPrice:e.gasPrice,maxFeePerGas:e.maxFeePerGas,maxPriorityFeePerGas:e.maxPriorityFeePerGas,chainId:parseInt(e.chainId)})}async connectSite(e,t,s){const a={eth_accounts:!1,eth_chainId:!1,personal_sign:!1,eth_sendTransaction:!1,wallet_switchEthereumChain:!1};s.forEach((e=>{e in a&&(a[e]=!0)})),this.state.connectedSites[e]={chainId:this.state.selectedNetwork.chainId,accounts:t,lastConnected:Date.now(),autoConnect:!0,permissions:a},await this.saveState()}async disconnectSite(e){delete this.state.connectedSites[e],await this.saveState()}async shouldAutoConnect(e){const t=this.state.connectedSites[e];if(!t||!t.autoConnect)return!1;return!(Date.now()-t.lastConnected>864e5)}async getSession(e){return this.state.connectedSites[e]}async updateNetwork(e,t){this.pendingNetworkUpdate&&clearTimeout(this.pendingNetworkUpdate),this.pendingNetworkUpdate=setTimeout((async()=>{await this.setNetwork(t),this.state.connectedSites[e]&&(this.state.connectedSites[e].chainId=t,await this.saveState())}),500)}async encryptSeed(e,t,s,a){const i=await this.deriveKey(t,s),r=(new TextEncoder).encode(e),n=await crypto.subtle.encrypt({name:"AES-GCM",iv:a},i,r);return E(new Uint8Array(n))}async decryptSeed(e,t,s,a){const i=await this.deriveKey(t,s),r=await crypto.subtle.decrypt({name:"AES-GCM",iv:a},i,b(e));return(new TextDecoder).decode(r)}async deriveKey(e,t){const s=(new TextEncoder).encode(e),a=await crypto.subtle.importKey("raw",s,{name:"PBKDF2"},!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:t,iterations:31e4,hash:"SHA-256"},a,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async getSeed(){if(!this.vault||!this.state.isUnlocked||!this.password)throw new Error("Wallet is locked");try{return await this.decryptSeed(this.vault.encryptedSeed,this.password,b(this.vault.salt),b(this.vault.iv))}catch(e){throw new Error("Failed to decrypt wallet seed")}}async signMessage(e,t){if(!this.vault||!this.state.isUnlocked)throw new Error("Wallet is locked");const s=await this.getSeed(),a=this.state.accounts.find((e=>e.address.toLowerCase()===t.toLowerCase()));if(!a)throw new Error("Account not found");const i=`m/44'/60'/0'/0/${a.index}`,r=M.fromMnemonic(s).derivePath(i),n=new S(r.privateKey);return await n.signMessage(e)}};export{I as w};
