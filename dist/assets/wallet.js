var e,t,a,s,i,r,n,o,c,h,l,d,w,u=Object.defineProperty,p=(e,t,a)=>(((e,t,a)=>{t in e?u(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a})(e,"symbol"!=typeof t?t+"":t,a),a),m=(e,t,a)=>{if(!t.has(e))throw TypeError("Cannot "+a)},y=(e,t,a)=>(m(e,t,"read from private field"),a?a.call(e):t.get(e)),v=(e,t,a)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,a)},g=(e,t,a,s)=>(m(e,t,"write to private field"),s?s.call(e,a):t.set(e,a),a),f=(e,t,a)=>(m(e,t,"access private method"),a);import{W as S,r as k,h as E,a as b,H as x,J as I}from"./ethers-vendor.js";import"./react-vendor.js";const N=(e,t,a,s)=>function(...i){return new(0,t.promiseModule)(((r,n)=>{t.multiArgs?i.push(((...e)=>{t.errorFirst?e[0]?n(e):(e.shift(),r(e)):r(e)})):t.errorFirst?i.push(((e,t)=>{e?n(e):r(t)})):i.push(r);const o=this===a?s:this;Reflect.apply(e,o,i)}))},C=new WeakMap;function M(e,t){t={exclude:[/.+(?:Sync|Stream)$/],errorFirst:!0,promiseModule:Promise,...t};const a=typeof e;if(null===e||"object"!==a&&"function"!==a)throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${null===e?"null":a}\``);const s=new WeakMap,i=new Proxy(e,{apply(e,a,r){const n=s.get(e);if(n)return Reflect.apply(n,a,r);const o=t.excludeMain?e:N(e,t,i,e);return s.set(e,o),Reflect.apply(o,a,r)},get(e,a){const r=e[a];if(!((e,a)=>{let s=C.get(e);if(s||(s={},C.set(e,s)),a in s)return s[a];const i=e=>"string"==typeof e||"symbol"==typeof a?a===e:e.test(a),r=Reflect.getOwnPropertyDescriptor(e,a),n=void 0===r||r.writable||r.configurable,o=(t.include?t.include.some((e=>i(e))):!t.exclude.some((e=>i(e))))&&n;return s[a]=o,o})(e,a)||r===Function.prototype[a])return r;const n=s.get(r);if(n)return n;if("function"==typeof r){const a=N(r,t,i,e);return s.set(r,a),a}return r}});return i}var A=(w=class{constructor({area:w="sync",allCopied:u=!1,copiedKeyList:m=[],serde:S={}}={}){v(this,c),v(this,l),v(this,e,void 0),v(this,t,void 0),v(this,a,void 0),v(this,s,void 0),v(this,i,new Map),v(this,r,void 0),p(this,"isCopied",(e=>this.hasWebApi&&(this.allCopied||this.copiedKeySet.has(e)))),v(this,n,!1),p(this,"getExtStorageApi",(()=>{var e,t;return(null==(e=globalThis.browser)?void 0:e.storage)||(null==(t=globalThis.chrome)?void 0:t.storage)})),p(this,"isWatchSupported",(()=>this.hasExtensionApi)),p(this,"keyNamespace",""),p(this,"isValidKey",(e=>e.startsWith(this.keyNamespace))),p(this,"getNamespacedKey",(e=>`${this.keyNamespace}${e}`)),p(this,"getUnnamespacedKey",(e=>e.slice(this.keyNamespace.length))),p(this,"serde",{serializer:JSON.stringify,deserializer:JSON.parse}),p(this,"rawGetAll",(()=>{var e;return null==(e=y(this,t))?void 0:e.get()})),p(this,"getAll",(async()=>{let e=await this.rawGetAll();return Object.entries(e).filter((([e])=>this.isValidKey(e))).reduce(((e,[t,a])=>(e[this.getUnnamespacedKey(t)]=a,e)),{})})),p(this,"copy",(async e=>{var s,i;let r=void 0===e;if(!r&&!this.copiedKeySet.has(e)||!this.allCopied||!this.hasExtensionApi)return!1;let n=this.allCopied?await this.rawGetAll():await y(this,t).get((r?[...this.copiedKeySet]:[e]).map(this.getNamespacedKey));if(!n)return!1;let o=!1;for(let t in n){let e=n[t],r=null==(s=y(this,a))?void 0:s.getItem(t);null==(i=y(this,a))||i.setItem(t,e),o||(o=e!==r)}return o})),p(this,"rawGet",(async e=>(await this.rawGetMany([e]))[e])),p(this,"rawGetMany",(async e=>this.hasExtensionApi?await y(this,t).get(e):e.filter(this.isCopied).reduce(((e,t)=>{var s;return e[t]=null==(s=y(this,a))?void 0:s.getItem(t),e}),{}))),p(this,"rawSet",(async(e,t)=>await this.rawSetMany({[e]:t}))),p(this,"rawSetMany",(async e=>(y(this,a)&&Object.entries(e).filter((([e])=>this.isCopied(e))).forEach((([e,t])=>y(this,a).setItem(e,t))),this.hasExtensionApi&&await y(this,t).set(e),null))),p(this,"clear",(async(e=!1)=>{var s;e&&(null==(s=y(this,a))||s.clear()),await y(this,t).clear()})),p(this,"rawRemove",(async e=>{await this.rawRemoveMany([e])})),p(this,"rawRemoveMany",(async e=>{y(this,a)&&e.filter(this.isCopied).forEach((e=>y(this,a).removeItem(e))),this.hasExtensionApi&&await y(this,t).remove(e)})),p(this,"removeAll",(async()=>{let e=await this.getAll(),t=Object.keys(e);await this.removeMany(t)})),p(this,"watch",(e=>{let t=this.isWatchSupported();return t&&y(this,o).call(this,e),t})),v(this,o,(t=>{var a;for(let s in t){let r=this.getNamespacedKey(s),n=(null==(a=y(this,i).get(r))?void 0:a.callbackSet)||new Set;if(n.add(t[s]),n.size>1)continue;let o=(e,t)=>{if(t!==this.area||!e[r])return;let a=y(this,i).get(r);if(!a)throw new Error(`Storage comms does not exist for nsKey: ${r}`);Promise.all([this.parseValue(e[r].newValue),this.parseValue(e[r].oldValue)]).then((([e,s])=>{for(let i of a.callbackSet)i({newValue:e,oldValue:s},t)}))};y(this,e).onChanged.addListener(o),y(this,i).set(r,{callbackSet:n,listener:o})}})),p(this,"unwatch",(e=>{let t=this.isWatchSupported();return t&&f(this,c,h).call(this,e),t})),p(this,"unwatchAll",(()=>f(this,l,d).call(this))),this.setCopiedKeySet(m),g(this,s,w),g(this,n,u),this.serde={...this.serde,...S};try{this.hasWebApi&&(u||m.length>0)&&g(this,a,window.localStorage)}catch{}try{this.hasExtensionApi&&(g(this,e,this.getExtStorageApi()),(()=>{var e,t,a;try{let s=(null==(e=globalThis.navigator)?void 0:e.userAgent).match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i)||[];if("Chrome"===s[1])return parseInt(s[2])<100||2===(null==(a=null==(t=globalThis.chrome.runtime)?void 0:t.getManifest())?void 0:a.manifest_version)}catch{return!1}return!1})()?g(this,t,M(y(this,e)[this.area],{exclude:["getBytesInUse"],errorFirst:!1})):g(this,t,y(this,e)[this.area]))}catch{}}get primaryClient(){return y(this,t)}get secondaryClient(){return y(this,a)}get area(){return y(this,s)}get hasWebApi(){try{return typeof window<"u"&&!!window.localStorage}catch(e){return!1}}get copiedKeySet(){return y(this,r)}get allCopied(){return y(this,n)}get hasExtensionApi(){try{return!!this.getExtStorageApi()}catch(e){return!1}}setCopiedKeySet(e){g(this,r,new Set(e))}async getItem(e){return this.get(e)}async getItems(e){return await this.getMany(e)}async setItem(e,t){await this.set(e,t)}async setItems(e){await await this.setMany(e)}async removeItem(e){return this.remove(e)}async removeItems(e){return await this.removeMany(e)}},e=new WeakMap,t=new WeakMap,a=new WeakMap,s=new WeakMap,i=new WeakMap,r=new WeakMap,n=new WeakMap,o=new WeakMap,c=new WeakSet,h=function(t){for(let a in t){let s=this.getNamespacedKey(a),r=t[a],n=y(this,i).get(s);n&&(n.callbackSet.delete(r),0===n.callbackSet.size&&(y(this,i).delete(s),y(this,e).onChanged.removeListener(n.listener)))}},l=new WeakSet,d=function(){y(this,i).forEach((({listener:t})=>y(this,e).onChanged.removeListener(t))),y(this,i).clear()},w);const K=new class extends A{constructor(){super(...arguments),p(this,"get",(async e=>{let t=this.getNamespacedKey(e),a=await this.rawGet(t);return this.parseValue(a)})),p(this,"getMany",(async e=>{let t=e.map(this.getNamespacedKey),a=await this.rawGetMany(t),s=await Promise.all(Object.values(a).map(this.parseValue));return Object.keys(a).reduce(((e,t,a)=>(e[this.getUnnamespacedKey(t)]=s[a],e)),{})})),p(this,"set",(async(e,t)=>{let a=this.getNamespacedKey(e),s=this.serde.serializer(t);return this.rawSet(a,s)})),p(this,"setMany",(async e=>{let t=Object.entries(e).reduce(((e,[t,a])=>(e[this.getNamespacedKey(t)]=this.serde.serializer(a),e)),{});return await this.rawSetMany(t)})),p(this,"remove",(async e=>{let t=this.getNamespacedKey(e);return this.rawRemove(t)})),p(this,"removeMany",(async e=>{let t=e.map(this.getNamespacedKey);return await this.rawRemoveMany(t)})),p(this,"setNamespace",(e=>{this.keyNamespace=e})),p(this,"parseValue",(async e=>{try{if(void 0!==e)return this.serde.deserializer(e)}catch(t){}}))}},U=1e4,P=[{chainId:"0x1",name:"Ethereum Mainnet",rpcUrl:"https://mainnet.infura.io/v3/6131105f1e4c4841a297c5392effa977",currencySymbol:"ETH",blockExplorerUrl:"https://etherscan.io",nativeCurrency:{name:"Ether",symbol:"ETH",decimals:18},blockExplorerUrls:["https://etherscan.io"]},{chainId:"0xaa36a7",name:"Sepolia Testnet",rpcUrl:"https://sepolia.infura.io/v3/6131105f1e4c4841a297c5392effa977",currencySymbol:"ETH",blockExplorerUrl:"https://sepolia.etherscan.io",nativeCurrency:{name:"Sepolia Ether",symbol:"ETH",decimals:18},blockExplorerUrls:["https://sepolia.etherscan.io"]},{chainId:"0xa",name:"Optimism",rpcUrl:"https://optimism-mainnet.infura.io/v3/6131105f1e4c4841a297c5392effa977",currencySymbol:"ETH",blockExplorerUrl:"https://optimistic.etherscan.io",nativeCurrency:{name:"Ether",symbol:"ETH",decimals:18},blockExplorerUrls:["https://optimistic.etherscan.io"]}];class W{constructor(){p(this,"vault",null),p(this,"state",{isUnlocked:!1,accounts:[],networks:P,selectedNetwork:P[0],connectedSites:{}}),p(this,"initPromise"),p(this,"pendingNetworkUpdate",null),p(this,"password",null),this.initPromise=this.loadState()}async loadState(){try{const e=await Promise.race([K.get("walletState"),new Promise(((e,t)=>setTimeout((()=>t(new Error("Loading state timed out"))),U)))]);e&&(this.state=JSON.parse(e))}catch(e){}}async saveState(){try{await Promise.race([K.set("walletState",JSON.stringify(this.state)),new Promise(((e,t)=>setTimeout((()=>t(new Error("Saving state timed out"))),U)))])}catch(e){throw new Error("Failed to save wallet state")}}async getState(){return await this.initPromise,this.state}async saveUsername(e){try{await Promise.race([K.set("username",e),new Promise(((e,t)=>setTimeout((()=>t(new Error("Saving username timed out"))),U)))])}catch(t){throw new Error("Failed to save username")}}async setConnected(e){try{this.state.isUnlocked=e,await this.saveState()}catch(t){throw new Error("Failed to set connection state")}}async hasWallet(){return!!(await K.get("vault"))}async isInitialized(){return!!(await K.get("vault"))}async resetWallet(){await this.initPromise,this.vault=null,this.state.isUnlocked=!1,this.state.accounts=[],this.state.selectedAccount=void 0,await this.saveState(),await K.remove("vault")}async createWallet(e,t=!1,a){var s;if(await this.initPromise,this.vault&&!t)throw new Error("Wallet already exists. Use force=true to overwrite existing wallet.");try{let t;if(t=a?S.fromMnemonic(a):await Promise.race([S.createRandom(),new Promise(((e,t)=>setTimeout((()=>t(new Error("Wallet creation timed out"))),U)))]),!(null==(s=t.mnemonic)?void 0:s.phrase))throw new Error("Failed to generate wallet mnemonic");const i=k(32),r=k(16),n=await this.encryptSeed(t.mnemonic.phrase,e,i,r);this.vault={encryptedSeed:n,salt:E(i),iv:E(r),version:1},this.password=e,await K.set("vault",this.vault),this.state.isUnlocked=!0,await this.saveState(),await new Promise((e=>setTimeout(e,100))),await this.addAccount("Account 1")}catch(i){throw this.vault=null,this.password=null,this.state.isUnlocked=!1,await this.saveState(),i instanceof Error?new Error(`Failed to create wallet: ${i.message}`):new Error("Failed to create wallet: Unknown error")}}async unlockWallet(e){const t=await K.get("vault");if(!t)throw new Error("No wallet found");try{await this.decryptSeed(t.encryptedSeed,e,b(t.salt),b(t.iv));return this.vault=t,this.state.isUnlocked=!0,await this.saveState(),!0}catch(a){return!1}}async addAccount(e){if(!this.vault||!this.state.isUnlocked)throw new Error("Wallet is locked");const t=this.state.accounts.length,a=`m/44'/60'/0'/0/${t}`,s=await this.getSeed(),i=x.fromMnemonic(s).derivePath(a),r=new S(i.privateKey),n={address:r.address,name:e||`Account ${t+1}`,index:t,balances:{},privateKey:r.privateKey};return this.state.accounts.push(n),this.state.selectedAccount||(this.state.selectedAccount=n),await this.saveState(),n}async getAccounts(){return this.state.accounts}async setNetwork(e){try{const r=e.startsWith("0x")?e.toLowerCase():"0x"+parseInt(e,10).toString(16),n=this.state.networks.find((t=>t.chainId.toLowerCase()===r||t.chainId===String(parseInt(r,16))||t.chainId===String(parseInt(e,10))));if(!n){const e=`[setNetwork] Network not found for chainId: ${r}`;throw new Error(e)}const o=new I(n.rpcUrl);try{const i=await o.getNetwork();if(String(i.chainId)!==String(parseInt(r,16))&&String(i.chainId)!==String(parseInt(e,10))){const e=`[setNetwork] Network chainId mismatch: expected ${r}, got ${i.chainId}`;throw new Error(e)}this.state.selectedNetwork=n;try{await this.saveState()}catch(t){}if(window.ethereum){const e=n.chainId.startsWith("0x")?n.chainId:"0x"+parseInt(n.chainId,10).toString(16);try{await window.ethereum.request({method:"wallet_switchEthereumChain",params:[{chainId:e}]})}catch(a){if(4902!==a.code){const e=`[setNetwork] Failed to update window.ethereum network: ${a&&a.message?a.message:a}`;throw new Error(e)}try{await window.ethereum.request({method:"wallet_addEthereumChain",params:[{chainId:e,chainName:n.name,nativeCurrency:n.nativeCurrency,rpcUrls:[n.rpcUrl],blockExplorerUrls:n.blockExplorerUrls,iconUrls:[]}]})}catch(s){const e=`[setNetwork] Failed to add network to window.ethereum: ${s}`;throw new Error(e)}}}}catch(i){const e=`[setNetwork] Failed to verify/connect to network: ${i instanceof Error?i.message:String(i)}`;throw new Error(e)}}catch(i){const e=`[setNetwork] Network switch failed: ${i instanceof Error?i.message:String(i)}`;throw new Error(e)}}async addNetwork(e){if(this.state.networks.some((t=>t.chainId===e.chainId)))throw new Error("Network already exists");this.state.networks.push(e),await this.saveState()}async signTransaction(e){if(!this.vault||!this.state.isUnlocked)throw new Error("Wallet is locked");const t=await this.getSeed(),a=this.state.accounts.find((t=>t.address.toLowerCase()===e.from.toLowerCase()));if(!a)throw new Error("Account not found");const s=`m/44'/60'/0'/0/${a.index}`,i=x.fromMnemonic(t).derivePath(s),r=new S(i.privateKey),n=new I(this.state.selectedNetwork.rpcUrl),o=r.connect(n);return await o.signTransaction({to:e.to,value:e.value,data:e.data,nonce:e.nonce,gasLimit:e.gasLimit,gasPrice:e.gasPrice,maxFeePerGas:e.maxFeePerGas,maxPriorityFeePerGas:e.maxPriorityFeePerGas,chainId:parseInt(e.chainId)})}async connectSite(e,t,a){const s={eth_accounts:!1,eth_chainId:!1,personal_sign:!1,eth_sendTransaction:!1,wallet_switchEthereumChain:!1};a.forEach((e=>{e in s&&(s[e]=!0)})),this.state.connectedSites[e]={chainId:this.state.selectedNetwork.chainId,accounts:t,lastConnected:Date.now(),autoConnect:!0,permissions:s},await this.saveState()}async disconnectSite(e){delete this.state.connectedSites[e],await this.saveState()}async shouldAutoConnect(e){const t=this.state.connectedSites[e];if(!t||!t.autoConnect)return!1;return!(Date.now()-t.lastConnected>864e5)}async getSession(e){return this.state.connectedSites[e]}async updateNetwork(e,t){this.pendingNetworkUpdate&&clearTimeout(this.pendingNetworkUpdate),this.pendingNetworkUpdate=setTimeout((async()=>{await this.setNetwork(t),this.state.connectedSites[e]&&(this.state.connectedSites[e].chainId=t,await this.saveState())}),500)}async encryptSeed(e,t,a,s){const i=await this.deriveKey(t,a),r=(new TextEncoder).encode(e),n=await crypto.subtle.encrypt({name:"AES-GCM",iv:s},i,r);return E(new Uint8Array(n))}async decryptSeed(e,t,a,s){const i=await this.deriveKey(t,a),r=await crypto.subtle.decrypt({name:"AES-GCM",iv:s},i,b(e));return(new TextDecoder).decode(r)}async deriveKey(e,t){const a=(new TextEncoder).encode(e),s=await crypto.subtle.importKey("raw",a,{name:"PBKDF2"},!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:t,iterations:31e4,hash:"SHA-256"},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async getSeed(){if(!this.vault||!this.state.isUnlocked||!this.password)throw new Error("Wallet is locked");try{return await this.decryptSeed(this.vault.encryptedSeed,this.password,b(this.vault.salt),b(this.vault.iv))}catch(e){throw new Error("Failed to decrypt wallet seed")}}async signMessage(e,t){if(!this.vault||!this.state.isUnlocked)throw new Error("Wallet is locked");const a=await this.getSeed(),s=this.state.accounts.find((e=>e.address.toLowerCase()===t.toLowerCase()));if(!s)throw new Error("Account not found");const i=`m/44'/60'/0'/0/${s.index}`,r=x.fromMnemonic(a).derivePath(i),n=new S(r.privateKey);return await n.signMessage(e)}async importAccountFromPrivateKey(e,t){if(!this.vault||!this.state.isUnlocked)throw new Error("Wallet is locked");const a=new S(e),s={address:a.address,name:t||`Imported Account ${this.state.accounts.length+1}`,index:this.state.accounts.length,balances:{},privateKey:a.privateKey};return this.state.accounts.push(s),await this.saveState(),s}}const T=new W;export{W as WalletService,T as walletService};
